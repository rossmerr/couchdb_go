// Code generated by go-swagger; DO NOT EDIT.

package database

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new database API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for database API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	BulkDocs(params *BulkDocsParams) (*BulkDocsCreated, error)

	BulkGet(params *BulkGetParams) (*BulkGetCreated, error)

	DbSecurityGet(params *DbSecurityGetParams) (*DbSecurityGetOK, error)

	Delete(params *DeleteParams) (*DeleteOK, *DeleteAccepted, error)

	DesignDocAllGet(params *DesignDocAllGetParams) (*DesignDocAllGetOK, error)

	DesignDocAllPost(params *DesignDocAllPostParams) (*DesignDocAllPostOK, error)

	DocGetAll(params *DocGetAllParams) (*DocGetAllOK, error)

	DocPostAll(params *DocPostAllParams) (*DocPostAllOK, error)

	Exists(params *ExistsParams) (*ExistsOK, error)

	Get(params *GetParams) (*GetOK, error)

	Put(params *PutParams) (*PutCreated, *PutAccepted, error)

	SbSecurityPut(params *SbSecurityPutParams) (*SbSecurityPutOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  BulkDocs thes bulk document API allows you to create and update multiple documents at the same time within a single request

  The basic operation is similar to creating or updating a single document, except that you batch the document structure and information.

When creating new documents the document ID (_id) is optional.

For updating existing documents, you must provide the document ID, revision information (_rev), and new document values.

In case of batch deleting documents all fields as document ID, revision information and deletion status (_deleted) are required.

*/
func (a *Client) BulkDocs(params *BulkDocsParams) (*BulkDocsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBulkDocsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "bulkDocs",
		Method:             "POST",
		PathPattern:        "/{db}/_bulk_docs",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BulkDocsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BulkDocsCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for bulkDocs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  BulkGet this method can be called to query several documents in bulk

  It is well suited for fetching a specific revision of documents, as replicators do for example, or for getting revision history.

*/
func (a *Client) BulkGet(params *BulkGetParams) (*BulkGetCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBulkGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "bulkGet",
		Method:             "POST",
		PathPattern:        "/{db}/_bulk_get",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "multipart/mixed", "multipart/related"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BulkGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BulkGetCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for bulkGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DbSecurityGet returns the current security object from the specified database

  The security object consists of two compulsory elements, admins and members, which are used to specify the list of users and/or roles that have admin and members rights to the database respectively:

  - members: they can read all types of documents from the DB, and they can write (and edit) documents to the DB except for design documents.
  - admins: they have all the privileges of members plus the privileges: write (and edit) design documents, add/remove database admins and members and set the database revisions limit. They can not create a database nor delete a database.

Both members and admins objects contain two array-typed fields:

  - names: List of CouchDB user names
  - roles: List of users roles

Any additional fields in the security object are optional. The entire security object is made available to validation and other internal functions so that the database can control and limit functionality.

If both the names and roles fields of either the admins or members properties are empty arrays, or are not existent, it means the database has no admins or members.

Having no admins, only server admins (with the reserved _admin role) are able to update design document and make other admin level changes.

Having no members, any user can write regular documents (any non-design document) and read documents from the database.

If there are any member names or roles defined for a database, then only authenticated users having a matching name or role are allowed to read documents from the database (or do a GET /{db} call).

*Note*
If the security object for a database has never been set, then the value returned will be empty.

Also note, that security objects are not regular versioned documents (that is, they are not under MVCC rules). This is a design choice to speed up authorization checks (avoids traversing a database’s documents B-Tree).

*/
func (a *Client) DbSecurityGet(params *DbSecurityGetParams) (*DbSecurityGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDbSecurityGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "dbSecurityGet",
		Method:             "GET",
		PathPattern:        "/{db}/_security",
		ProducesMediaTypes: []string{"application/json", "text/plan"},
		ConsumesMediaTypes: []string{"application/json", "text/plan"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DbSecurityGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DbSecurityGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for dbSecurityGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  Delete deletes the specified database and all the documents and attachments contained within it

  *Note*
To avoid deleting a database, CouchDB will respond with the HTTP status code 400 when the request
URL includes a ?rev= parameter. This suggests that one wants to delete a document but forgot to add
the document id to the URL.

*/
func (a *Client) Delete(params *DeleteParams) (*DeleteOK, *DeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete",
		Method:             "DELETE",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteOK:
		return value, nil, nil
	case *DeleteAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for database: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DesignDocAllGet returns a JSON structure of all of the design documents in a given database

  The information is returned as a JSON structure containing meta information about the return structure, including a list of all design documents and basic contents, consisting the ID, revision and key. The key is the design document’s _id.

*/
func (a *Client) DesignDocAllGet(params *DesignDocAllGetParams) (*DesignDocAllGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDesignDocAllGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "designDocAllGet",
		Method:             "GET",
		PathPattern:        "/{db}/_design_docs",
		ProducesMediaTypes: []string{"application/json", "text/plan"},
		ConsumesMediaTypes: []string{"application/json", "text/plan"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DesignDocAllGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DesignDocAllGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for designDocAllGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DesignDocAllPost ps o s t design docs functionality supports identical parameters and behavior as specified in the g e t db design docs

  API but allows for the query string parameters to be supplied as keys in a JSON object in the body of the POST request.

*/
func (a *Client) DesignDocAllPost(params *DesignDocAllPostParams) (*DesignDocAllPostOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDesignDocAllPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "designDocAllPost",
		Method:             "POST",
		PathPattern:        "/{db}/_design_docs",
		ProducesMediaTypes: []string{"application/json", "text/plan"},
		ConsumesMediaTypes: []string{"application/json", "text/plan"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DesignDocAllPostReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DesignDocAllPostOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for designDocAllPost: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocGetAll executes the built in all docs view

  returning all of the documents in the database. With the exception of the URL parameters
(described below), this endpoint works identically to any other view. Refer to the view endpoint
documentation for a complete description of the available query parameters and the format of
the returned data.

*/
func (a *Client) DocGetAll(params *DocGetAllParams) (*DocGetAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocGetAllParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "docGetAll",
		Method:             "GET",
		PathPattern:        "/{db}/_all_docs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocGetAllReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DocGetAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for docGetAll: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocPostAll executes the built in all docs view

  POST _all_docs functionality supports identical parameters and behavior as specified in the
GET /{db}/_all_docs API but allows for the query string parameters to be supplied as keys in a
JSON object in the body of the POST request.

*/
func (a *Client) DocPostAll(params *DocPostAllParams) (*DocPostAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocPostAllParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "docPostAll",
		Method:             "POST",
		PathPattern:        "/{db}/_all_docs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocPostAllReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DocPostAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for docPostAll: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  Exists returns the HTTP headers containing a minimal amount of information about the specified database

  Since the response body is empty, using the HEAD method is a lightweight way to check if the database exists already or not.

*/
func (a *Client) Exists(params *ExistsParams) (*ExistsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExistsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "exists",
		Method:             "HEAD",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ExistsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExistsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for exists: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  Get gets information about the specified database

  By passing in the appropriate options, you can search for
available inventory in the system

*/
func (a *Client) Get(params *GetParams) (*GetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get",
		Method:             "GET",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for get: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  Put creates a new database

  The database name {db} must be composed by following next rules:
Name must begin with a lowercase letter (a-z)
* Lowercase characters (a-z)
* Digits (0-9)
* Any of the characters _, $, (, ), +, -, and /.

If you’re familiar with Regular Expressions, the rules above could be written as

*/
func (a *Client) Put(params *PutParams) (*PutCreated, *PutAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "put",
		Method:             "PUT",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutCreated:
		return value, nil, nil
	case *PutAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for database: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SbSecurityPut sets the security object for the given database
*/
func (a *Client) SbSecurityPut(params *SbSecurityPutParams) (*SbSecurityPutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSbSecurityPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sbSecurityPut",
		Method:             "PUT",
		PathPattern:        "/{db}/_security",
		ProducesMediaTypes: []string{"application/json", "text/plan"},
		ConsumesMediaTypes: []string{"application/json", "text/plan"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SbSecurityPutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SbSecurityPutOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for sbSecurityPut: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
