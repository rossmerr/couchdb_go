// Code generated by go-swagger; DO NOT EDIT.

package database

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new database API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for database API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	BulkGetAll(params *BulkGetAllParams) (*BulkGetAllOK, error)

	BulkPostAll(params *BulkPostAllParams) (*BulkPostAllCreated, error)

	DbDelete(params *DbDeleteParams) (*DbDeleteOK, *DbDeleteAccepted, error)

	DbGet(params *DbGetParams) (*DbGetOK, error)

	DbHeader(params *DbHeaderParams) (*DbHeaderOK, error)

	DbPut(params *DbPutParams) (*DbPutCreated, *DbPutAccepted, error)

	DesignGet(params *DesignGetParams) (*DesignGetOK, error)

	DesignPost(params *DesignPostParams) (*DesignPostOK, error)

	DocGetAll(params *DocGetAllParams) (*DocGetAllOK, error)

	DocPostAll(params *DocPostAllParams) (*DocPostAllOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  BulkGetAll this method can be called to query several documents in bulk

  It is well suited for fetching a specific revision of documents, as replicators do for example, or for getting revision history.

*/
func (a *Client) BulkGetAll(params *BulkGetAllParams) (*BulkGetAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBulkGetAllParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "bulkGetAll",
		Method:             "GET",
		PathPattern:        "/{db}/_bulk_get",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "multipart/mixed", "multipart/related"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BulkGetAllReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BulkGetAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for bulkGetAll: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  BulkPostAll thes bulk document API allows you to create and update multiple documents at the same time within a single request

  The basic operation is similar to creating or updating a single document, except that you batch the document structure and information.

When creating new documents the document ID (_id) is optional.

For updating existing documents, you must provide the document ID, revision information (_rev), and new document values.

In case of batch deleting documents all fields as document ID, revision information and deletion status (_deleted) are required.

*/
func (a *Client) BulkPostAll(params *BulkPostAllParams) (*BulkPostAllCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBulkPostAllParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "bulkPostAll",
		Method:             "POST",
		PathPattern:        "/{db}/_bulk_get",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BulkPostAllReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BulkPostAllCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for bulkPostAll: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DbDelete deletes the specified database and all the documents and attachments contained within it

  *Note*
To avoid deleting a database, CouchDB will respond with the HTTP status code 400 when the request
URL includes a ?rev= parameter. This suggests that one wants to delete a document but forgot to add
the document id to the URL.

*/
func (a *Client) DbDelete(params *DbDeleteParams) (*DbDeleteOK, *DbDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDbDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "dbDelete",
		Method:             "DELETE",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DbDeleteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DbDeleteOK:
		return value, nil, nil
	case *DbDeleteAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for database: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DbGet gets information about the specified database

  By passing in the appropriate options, you can search for
available inventory in the system

*/
func (a *Client) DbGet(params *DbGetParams) (*DbGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDbGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "dbGet",
		Method:             "GET",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DbGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DbGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for dbGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DbHeader returns the HTTP headers containing a minimal amount of information about the specified database

  Since the response body is empty, using the HEAD method is a lightweight way to check if the database exists already or not.

*/
func (a *Client) DbHeader(params *DbHeaderParams) (*DbHeaderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDbHeaderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "dbHeader",
		Method:             "HEAD",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DbHeaderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DbHeaderOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for dbHeader: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DbPut creates a new database

  The database name {db} must be composed by following next rules:
Name must begin with a lowercase letter (a-z)
* Lowercase characters (a-z)
* Digits (0-9)
* Any of the characters _, $, (, ), +, -, and /.

If you’re familiar with Regular Expressions, the rules above could be written as

*/
func (a *Client) DbPut(params *DbPutParams) (*DbPutCreated, *DbPutAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDbPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "dbPut",
		Method:             "PUT",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DbPutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DbPutCreated:
		return value, nil, nil
	case *DbPutAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for database: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DesignGet returns a JSON structure of all of the design documents in a given database

  The information is returned as a JSON structure containing meta information about the return structure, including a list of all design documents and basic contents, consisting the ID, revision and key. The key is the design document’s _id.

*/
func (a *Client) DesignGet(params *DesignGetParams) (*DesignGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDesignGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "designGet",
		Method:             "GET",
		PathPattern:        "/{db}/_design_docs",
		ProducesMediaTypes: []string{"application/json", "text/plan"},
		ConsumesMediaTypes: []string{"application/json", "text/plan"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DesignGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DesignGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for designGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DesignPost ps o s t design docs functionality supports identical parameters and behavior as specified in the g e t db design docs

  API but allows for the query string parameters to be supplied as keys in a JSON object in the body of the POST request.

*/
func (a *Client) DesignPost(params *DesignPostParams) (*DesignPostOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDesignPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "designPost",
		Method:             "POST",
		PathPattern:        "/{db}/_design_docs",
		ProducesMediaTypes: []string{"application/json", "text/plan"},
		ConsumesMediaTypes: []string{"application/json", "text/plan"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DesignPostReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DesignPostOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for designPost: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocGetAll executes the built in all docs view

  returning all of the documents in the database. With the exception of the URL parameters
(described below), this endpoint works identically to any other view. Refer to the view endpoint
documentation for a complete description of the available query parameters and the format of
the returned data.

*/
func (a *Client) DocGetAll(params *DocGetAllParams) (*DocGetAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocGetAllParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "docGetAll",
		Method:             "GET",
		PathPattern:        "/{db}/_all_docs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocGetAllReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DocGetAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for docGetAll: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocPostAll executes the built in all docs view

  POST _all_docs functionality supports identical parameters and behavior as specified in the
GET /{db}/_all_docs API but allows for the query string parameters to be supplied as keys in a
JSON object in the body of the POST request.

*/
func (a *Client) DocPostAll(params *DocPostAllParams) (*DocPostAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocPostAllParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "docPostAll",
		Method:             "POST",
		PathPattern:        "/{db}/_all_docs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocPostAllReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DocPostAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for docPostAll: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
